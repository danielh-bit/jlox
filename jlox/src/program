var a = "global";
{
  fun showA() {
    print a;
  }

  showA();
  var a = "block";
  showA();
}



/*
idea -> everything is a function until evaluated...
probably just Lambda calculus but will try to do it in unique ways maybe.


fn add_two.x
    x + 2

print x(3)


fn add. fn y. x
    y + x

print add(3)(2) // this makes sense because i give 3 to the inner function and 2 to the outer, this gets evaluated to 3 + 2

// prints 6

*
the second example is valid because all functions are expressions, and all expressions are values.
this mean I can give 3 as input while the declaration is requesting a function.
if i `print add(3)`
OUTPUT: y + 3
and the input to y

the inner is the first in the input chain, it goes the outer on the second.


function declaration:
    fn <name>.<input> : <out type>
        CODE BLOCK
        <return that is in <out type>>
or:
    fn <name>.<input> : <out type> -> <return that is in <out type>>

example:
    fn add_2.x : int
        x + 2

example:
    fn add.fn y.x : int -> x + y : int




need to refine this design for function currying that takes in more complex functions.
it could be that modern C style programming languages have made that case cleaner with `fn x(i : type, k : type) -> type`

    fn add.(fn y.x : int -> int) -> int
        x + y

    print add(3)(2)
    // 5
    print add(add(1))(2)
    // 5

this works because add(1) returns fn<1 + y>.y : int -> int
this means that at this stage the beta evaluation of add is:
    1 + y + y
this is a function that can be written: fn<1 + 2y>.y : int -> int
when we give 2 as input to this function the beta evaluation will be:
    1 + 2 * 2

another example:

    add(add(1))(add(1))(1)

the beta evaluations:
    1 + 2y
    1 + 2(1 + y) = 3 + 2y
    3 + 2 * 1 = 5

the only thin that is left is to thoroughly define why the Ys get added and aren't considered different inputs...
the answer to this could be a special ID that is based on the name of the variable. where the environment hash map will
look like this: HM env<HM ID<int id, string name>, Object value>; (env<HM, String>)
this way multiple ids could be assigned to the same name.
and the explanation for why the previous program runs this way will be that the add(x) will return a function that
has the same ID for its input `y`. the counter example is:

    fn different.(fn k.z: int -> int) -> int
        z

    add(different(add(1))(1)

this will evaluate to:
    different(add(1)) + y = add(1) + y = 1 + y1 + y
    1 + y1 + 1 = 2 + y1

this function will not evaluate because the IDs of the inputs were different. To evaluate it:
    add(different(add(1))(1)(3)

which will evaluate to:
    2 + y1
    2 + 3 = 5
*/